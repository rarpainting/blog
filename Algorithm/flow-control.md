# 流量控制

## 现有控制

假设现在 消费速率(consumption rate) 低于 生产速率(production rate)

### Back-Pressure

- 将当前消费速率通知到生产者, 以降低生产效率
- cold observable

### Throttling

- 生产, 消费速率都不变
- 消费者只消费能消费的, 其余丢弃

### Buffer/Window

- 生产者打包发送, 消费者一次性消费

### Reactive Pull

1. 生产者在没有消费者时不生产
2. 在消费者上线并告知消费效率后, 生产者最多生产满足消费的数据量(withTimeout)
3. 消费者取到数据, 生产者再次暂停, 等待消费者请求

### Callstack-Blocking

- 以消费者的速率限制整个调用链

# 高并发限流

## 基础算法

### 漏桶算法

- 接收请求, 并以限定量出流来稳定速率
- 抛弃溢出处理上限的请求

### 令牌桶算法

网络流量整形(Traffic Shaping) 以及 速率限制(Rate Limiting)

控制发送到网络上的数据的数目, 并 **允许突发数据的发送**

- 以一个恒定的速度往桶里放入令牌
- 如果请求需要被处理, 则需要先从桶里获取一个令牌; 当桶里没有令牌可取时, 则拒绝服务

## 具体算法

### Leaky Bucket

典型漏桶算法

### Fixed Window

固定窗口
- 设置一个时间段内(窗口)接收的请求数, 超过的这个请求数的请求会被丢弃
- 优点:
  - 有一定的时序性, 能处理突发数据
- 缺点:
  - 在窗口的起始时间, 最差情况下可能会带来 2 倍的流量(前面的数据未处理完, 又开新窗口)
  - 大量消费者等待窗口被重置, 在重置时刻造成惊群效应

### Sliding Log

- 利用记录下来的 **用户** 的请求时间, 请求数, 当该用户的一个新的请求进来时, 比较这个用户在 **这个窗口** 内的请求数是否超过了 **限定值** , 超过的话就拒绝这个请求
- 优点:
  - 避免了固定窗口算法在窗口边界可能出现的两倍流量问题
  - 由于是针对每个用户进行统计的，不会引发惊群效应
- 缺点:
  - 大量的请求日志持久化操作
  - 在分布式系统中, 请求日志也需要做分布式

### Sliding Window

- 为每个窗口进行请求量的计数
- 结合 上一个窗口的请求量 和 当前一个窗口{已经经过的时间/请求量/时段} 来计算出上限, 以此 **平滑请求尖锋**

优点:
- 避免了漏桶算法带来的 饥饿问题
- 避免了固定窗口算法的 请求量突增问题

## 分布式实现
