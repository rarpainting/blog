# Lock In MySQL

## 锁级别

### MDL -- meta data lock

管理表的列定义

### 表级锁 -- TM

- 开销小, 加锁快
- 不会出现死锁
- 锁定**颗粒大**, 锁冲突**概率高**, 并发低

### 行级锁 -- TX

- 开销大, 加锁慢
- 可能出现死锁
- 锁定**颗粒小**, 锁冲突**概率低**, 并发高

### 页面锁

- 开销和加锁时间都在 表级锁 和 行级锁 之间
- 可能出现死锁
- 锁定颗粒在于表锁和行锁之间

## 具体算法

### Next KeyLock

行锁 + Gap 锁 统称 Next keyLock

查询(select) 的时候使用 `lock in share mode` 或者 `for update` 会导致该查询放弃该事务的视图, 而转用最新的视图(可能是 行锁 的添加 S 锁/ X 锁); 破坏了读可重复性, 但是由于不需要回滚 MVCC 版本, 查询效率更高(尤其是该查询的目标表已经进行了大量的更改)

### Gap 锁(间隙锁)

Gap 锁 只在 可重复读(REPEATABLE READ) 隔离级别下有效

- Gap 锁特性是 前开后闭 -- { [n, m), 其中 m>n }
- Gap 锁之间 不冲突
- Gap 锁 与 相关操作(CUDA) 冲突

### RecordLock

锁数据

## 乐观锁

- 简单: 版本号 + 重试方式
