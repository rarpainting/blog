# 阿里 JAVA 手册存疑/点评/思考

## 异常处理 日志规约

### (一)异常处理

#### 捕获异常后不允许无视异常; 最外层的业务代码必须处理异常, 并将之转化为可理解的内容

#### 禁止出现 NPE 问题, 如果方法的返回值可能为 null, 应该注释说明具体情况

#### 注意 NPE 的出现场景:

- 在 return 基本数据类型到封装过的数据类型时, 即自动拆箱时可能出现

- 远程调用返回对象, 一律进行空指针判断

#### 不允许在业务最外层使用内建异常, 应当使用由业务含义的自定义异常

#### 以下是建议的错误处理

- 应用内部抛出异常
- 跨应用间 RPC 调用优先考虑 Result
- 可选: 封装 isSuccess/isErr 方法, 错误码, 错误简短信息

关于 RPC 方法返回方式使用 Result 方式的理由:

1. 使用抛异常返回方式, 调用方如果没有捕获到就会产生运行时错误;

2. 如果不加栈信息, 只是 new 自定义异常, 加入自己的理解的 error message, 对于调用端解决问题的帮助不会太多. 如果加了栈信息, 在频繁调用出错的情况下, 数据序列化和传输的性能损耗也是问题

### 日志规约

#### 日志文件推荐至少保存 15 天, 因为部分异常具备以"周"发生的频次

#### 使用门面模式的日志框架, 有利于维护和各个类的日志处理方式统一

#### 应用扩展日志命名方式 **appName_logType_logName.log**

- logType: 日志类型, 推荐分类: stats desc monitor visit

- logName: 日志描述

推荐对日志进行分类, 将错误日志和业务日志区分, 便于 debug

#### 对 trace debug info 级别的日志输出, 必须使用条件输出形式 或者 占位符

说明: 无论是否处于能输出的级别, 都会执行字符串拼接动作, 浪费了系统资源

*细节, 铭记*

#### 异常信息包括两类信息: 案发现场信息 异常堆栈信息. 如果不处理, 则 抛出错误

#### 谨慎的记录日志 生产环境禁止输出 debug

#### 通过 warn 日志记录 用户输入参数错误 的情况; error 日志只记录 系统逻辑出错 异常 等错误信息

PS: golang 中 fallthrough 导致 case 语段不退出而继续实行下一条 case 语段, 且**不判断** case 条件

---

## 集合处理 并发处理

### OOP 规约

#### 类成员与方法访问

- 如果不允许外部直接通过 new 来构建对象, 那么构造方法必须为 private

- 工具类 不允许有 public 或 default

- 类非 static 成员变量/与子类共享 必须为 protected

- 类非 static 成员并且只在本类使用 必须为 private

- 类 static 成员并且只在本类使用 必须为 private

- 若是 static 成员 必须考虑是否为 final

- 类成员方法只供内部调用 必须为 private

- 类成员方法只对继承类公开 那么限制为 protected

### 集合处理

#### PECS(Producer Extends Customer Super) 原则

- 参数化类型表示一个生产者 适合使用 上界 Extends
  - <? extends T>: 类型为 T 的*子*类型 且 只读不可写(添加)
- 参数化类型表示一个消费者 适合使用 下界 Super
  - <? super T>: 类型为 T 的*父*类型 且 只写不可读

JAVA 泛型:
```java
HashMap<T extends String>
HashMap<? extends String>
HashMap<T super String>
HashMap<? super String>
```

#### 不在 foreach 中对本元素进行 remove/add 操作

remove 操作使用 Iterator 方式; 如果是并发操作, 需要对 Iterator 加锁

#### Map Slice 初始化时指定初始值大小

inititalMap = (storing elements) / (loader factor) + 1

注意:
- loader factor 一般取 0.75
- 如果无法确定初始值大小, 取 16

#### 利用 Set 的 元素唯一特性 能够快速对集合去重

#### 线程资源必须通过 线程池 提供, 不允许在应用中自行显式创建线程

#### 高并发时, 同步调用应高考量锁的性能损耗

- 使加锁的代码块工作量尽可能少, 避免在被锁的代码中调用 RPC

---

## MySQL 数据库

### (一)建表规范

#### 禁用保留字 desc range match delayed ...

#### 为索引字段添加索引属性

说明: 如主键索引为 pk\_字段名, 唯一索引为 uk\_字段名

#### 字段允许适当冗余, 以提高查询效率, 都必须考虑数据一致性

说明-冗余字段遵循:

- 不是频繁修改的字段

- 不是 varchar 超长字段, 更不能是 text 字段

### (二)索引规范

#### 业务上具有唯一特性的字段, 即使是多个字段的组合, 也必须建成唯一字段

*记录, 暂不评价*

#### 超过三个表禁止 join. 需要join 的字段, 数据类型必须一致; 多表关联查询时, 保证被关联的字段需要有索引

#### 页面搜索禁止左模糊或全模糊, 必要时通过搜索引擎解决

说明: 索引文件具有 B-tree 的最左前缀匹配特性, 如果最左的值未确定, 那么无法使用此索引

#### 利用覆盖索引来进行查询操作, 避免回表

### (三)SQL 语句

#### 建组合索引时, 区分度最高在左边, 等号条件置左边

#### 分页查询逻辑, 若 count 为 0 直接返回

*事实上 0 可以设置设置一个阈值, 用作直接返回的标准*

### (四)ORM 映射

#### 不使用 ResultClass 当返回参数, 即使所有类属性名与数据库字段一一对应, 也应当定义

*理解, 待实行*

#### 不允许直接以 HashMap 与 HashTable 作为查询结果的返回值
