# C++

## Lambda

形如

```cpp
[capture list] (params list) mutable exception-> return type { function body }
```

- capture list: 捕获外部变量列表
- params list: 形参列表
- mutable 指示符: 用来说用是否可以修改捕获的变量
- exception: 异常设定
- return type: 返回类型
- function body: 函数体

| 捕捉方式       | 说明                                                                                          |
| :-             | :-                                                                                            |
| `[]`           | 	不捕获任何外部变量                                                                        |
| `[变量名, …]` | 默认以值得形式捕获指定的多个外部变量(用逗号分隔), 如果引用捕获, 需要显示声明(使用&说明符) |
| `[this]`       | 	以值的形式捕获 this 指针                                                                  |
| `[=]`          | 	以值的形式捕获所有外部变量                                                                |
| `[&]`          | 以引用形式捕获所有外部变量                                                                    |
| `[=, &x]`      | 	变量 x 以引用形式捕获, 其余变量以传值形式捕获                                            |
| `[&, x]`       | 	变量 x 以值的形式捕获, 其余变量以引用形式捕获                                            |

Lambda 表达式的参数限制:
- 参数列表中不能有默认参数(可惜了)
- 不支持可变参数
- 所有参数必须有参数名

## 左值/右值

[C++ 左值与右值 ?](https://www.zhihu.com/question/26203703)

提示:
- 可被 & 取址的是左值, 不能被取址的是右值
- 左值和右值表达式都可以是 const 或 non-const

- 右值的目的是延长用来初始化对象的生命周期
- 右值经初始化后, 成为左值

## 多态

虚函数/类:
1. 编译时, 编译器会为每个包含虚函数的类创建一个虚表(vtable), 该表是一个一维数组, 在这个数组中存放每个虚函数的地址; 第一次触发类构造函数时, 该类相关的虚表被初始化
2. 虚表指针(vfptr) / 虚继承表指针(vbptr)
  1. (vs2002) 类 A 的虚表 **唯一** 创建在定义该类的模块中
  2. 虚表绑定类, 虚表指针帮动类对象
3. 虚表可以继承, 如果子类没有重写虚函数, 那么子类虚表中仍然会有该函数的地址, 只不过这个地址指向的是基类的虚函数实现
4. 如果基类有 n 个虚函数, 那么基类的虚表中就有 n 项(虚函数地址), 派生类也会有至少 n 项的虚表
3. 派生类的虚表中虚地址的排列顺序和基类的虚表中虚函数地址排列顺序相同
4. 采用晚绑定/运行时绑定, 在运行时, 依据对象的类型来确认调用的是哪一个虚函数实现
5. 早期绑定, 编译时绑定

纯虚函数/类:
1. 纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间

## 只能使用 initalization list 而不能 assignment

1. const 成员变量/ reference(引用) 成员变量 ; 他们只能在初始化列表初始化, 而不能赋值运算
2. 没有默认构造函数 `instance()` 的类类型
